#
# This file is part of LitePCIe.
#
# Copyright (c) 2015-2018 Florent Kermarrec <florent@enjoy-digital.fr>
# SPDX-License-Identifier: BSD-2-Clause

# In this high level test, LitePCIeEndpoint is connected to LitePCIeDMAReader and LitePCIeDMAWriter
# frontends with Reader's source connected to Writer's sink. Our Host model is used to emulate a Host
# memory with the Reader and Writer are reading/writing data from/to this memory. The Host memory
# is initially filled with random data, that are read by the Reader, re-directed to the Writer and
# then re-written in another memory location of the Host. The test then checks that the initial data
# and re-written data are identical.

import unittest

from litex.soc.interconnect import wishbone

from litepcie.common import *
from litepcie.core import LitePCIeEndpoint
from litepcie.core.msi import LitePCIeMSI
from litepcie.frontend.dma import LitePCIeDMAWriter, LitePCIeDMAReader
from cores.dma.mm2s import DMARam

root_id     = 0x100
endpoint_id = 0x400

def seed_to_data(seed, random=True):
    if random:
        return (seed * 0x31415979 + 1) & 0xffffffff
    else:
        return seed

class DMADriver:
    """DMA Driver model

    Provides methods to control/program LitePCIeDMAReader/LitePCIeDMAWriter.
    """
    def __init__(self, dma, dut):
        self.dma = getattr(dut, dma)
        self.dut = dut

    def set_prog_mode(self):
        yield from self.dma.table.loop_prog_n.write(0)

    def set_loop_mode(self):
        yield from self.dma.table.loop_prog_n.write(1)

    def flush(self):
        yield from self.dma.table.reset.write(1)

    def program_descriptor(self, address, length):
        value = address
        value |= (length << 32)
        yield from self.dma.table.value.write(value)
        yield from self.dma.table.we.write(1)

    def enable(self):
        yield from self.dma.enable.write(1)

    def disable(self):
        yield from self.dma.enable.write(0)

DMA_READER_IRQ = 1
DMA_WRITER_IRQ = 2

class MSIHandler(Module):
    """MSI Handled model

    Handles the MSI IRQs generated by LitePCIeDMAReader/LitePCIeDMAWriter.
    """
    def __init__(self, debug=False):
        self.debug = debug
        self.sink  = stream.Endpoint(msi_layout())

        self.dma_reader_irq_count = 0
        self.dma_writer_irq_count = 0

    def clear_dma_reader_irq_count(self):
        self.dma_reader_irq_count = 0

    def clear_dma_writer_irq_count(self):
        self.dma_writer_irq_count = 0

    @passive
    def generator(self, dut):
        while True:
            yield self.sink.ready.eq(1)
            if (yield self.sink.valid):
                # Get IRQs
                irq_vector = (yield dut.msi.vector.status)
                irq_clear  = 0

                # Handle IRQs
                if irq_vector & DMA_READER_IRQ:
                    self.dma_reader_irq_count += 1
                    if self.debug:
                        print("[MSI] dma_reader_irq (n: {:d})".format(self.dma_reader_irq_count))
                    irq_clear |= DMA_READER_IRQ

                if irq_vector & DMA_WRITER_IRQ:
                    self.dma_writer_irq_count += 1
                    if self.debug:
                        print("[MSI] dma_writer_irq (n: {:d})".format(self.dma_writer_irq_count))
                    irq_clear |= DMA_WRITER_IRQ
                # Clear IRQs
                yield from dut.msi.clear.write((yield from dut.msi.clear.read()) | irq_clear)
            yield

class _StubPHY(Module):
    def __init__(self, data_width, id, bar0_size, debug):
        self.data_width = data_width

        self.id = id

        self.bar0_size = bar0_size
        self.bar0_mask = get_bar_mask(bar0_size)

        self.max_request_size = Signal(10, reset=512)
        self.max_payload_size = Signal(8, reset=128)
        
        self.sink = stream.Endpoint(phy_layout(data_width))
        self.source = stream.Endpoint(phy_layout(data_width))
        self.submodules.fifo_sink = stream.SyncFIFO(phy_layout(data_width), depth=16)
        self.submodules.fifo_source = stream.SyncFIFO(phy_layout(data_width), depth=16)
        self.comb += [
            self.sink.connect(self.fifo_sink.sink),
            self.fifo_source.source.connect(self.source),
        ]
    
# DMA Memory
class _DMAMem(Module):
    def __init__(self, data_width, id, test_size, phy_debug = False):
        self.submodules.phy = phy = _StubPHY(data_width, id, 1 * MB, phy_debug)
        self.submodules.endpoint = endpoint = LitePCIeEndpoint(phy)
        
        port = endpoint.crossbar.get_slave_port(lambda a: 1)
        self.submodules.dmaram = dmaram = DMARam(data_width, test_size)
        self.comb += [
            dmaram.source.connect(port.source),
            port.sink.connect(dmaram.sink)
        ]
        
class TestDMA(unittest.TestCase):
    def dma_test(self, data_width, test_size=1024, vcd_name = ""):
        host_data     = [seed_to_data(i, True) for i in range(test_size//4)]
        loopback_data = []

        def main_generator(dut, nreads=8, nwrites=8):

            # DMA Reader/Writer control models
            dma_reader_driver = DMADriver("dma_reader", dut)
            dma_writer_driver = DMADriver("dma_writer", dut)

            # Program DMA Reader descriptors
            yield from dma_reader_driver.set_prog_mode()
            yield from dma_reader_driver.flush()
            for i in range(nreads):
                yield from dma_reader_driver.program_descriptor((test_size//8)*i, test_size//8)

            # Program DMA Writer descriptors
            yield from dma_writer_driver.set_prog_mode()
            yield from dma_writer_driver.flush()
            for i in range(nwrites):
                yield from dma_writer_driver.program_descriptor(test_size + (test_size//8)*i, test_size//8)

            # Enable MSI
            yield dut.msi.enable.storage.eq(DMA_READER_IRQ | DMA_WRITER_IRQ)

            # Enable DMA Reader & Writer
            yield from dma_reader_driver.enable()
            yield from dma_writer_driver.enable()

            # Wait for all writes
            while dut.msi_handler.dma_writer_irq_count != nwrites:
                yield

            # Delay to ensure all the data has been written
            for i in range(1024):
                yield

        class DUT(Module):
            def __init__(self, data_width):
                self.submodules.phy = phy = _StubPHY(data_width, endpoint_id, 1 * MB, False)

                # Endpoint -------------------------------------------------------------------------
                self.submodules.endpoint   = LitePCIeEndpoint(self.phy, max_pending_requests=8)
                
                # DMA Reader/Writer ----------------------------------------------------------------
                dma_reader_port = self.endpoint.crossbar.get_master_port(read_only=True)
                dma_writer_port = self.endpoint.crossbar.get_master_port(write_only=True)

                self.submodules.dma_reader = LitePCIeDMAReader(self.endpoint, dma_reader_port)
                self.submodules.dma_writer = LitePCIeDMAWriter(self.endpoint, dma_writer_port)
                self.comb += self.dma_reader.source.connect(self.dma_writer.sink)

                # MSI ------------------------------------------------------------------------------
                self.submodules.msi = LitePCIeMSI(2)
                self.comb += [
                    self.msi.irqs[log2_int(DMA_READER_IRQ)].eq(self.dma_reader.irq),
                    self.msi.irqs[log2_int(DMA_WRITER_IRQ)].eq(self.dma_writer.irq)
                ]
                self.submodules.msi_handler = MSIHandler(debug=False)
                self.comb += self.msi.source.connect(self.msi_handler.sink)
                
                self.submodules.memory = mem = _DMAMem(data_width, endpoint_id + 1, test_size)
                self.comb += [
                    # mem | -> | dut
                    mem.phy.fifo_sink.source.connect(phy.fifo_source.sink),
                    phy.fifo_sink.source.connect(mem.phy.fifo_source.sink),
                ]
                self.monitor_eps = {
                    "phy_src"         : phy.source,
                    "phy_snk"         : phy.sink,
                    "depacketizer_in" : self.endpoint.depacketizer.sink,
                    "req_source"      : self.endpoint.depacketizer.req_source,
                    "cmp_source"      : self.endpoint.depacketizer.cmp_source,
                    "req_sink"        : self.endpoint.packetizer.req_sink,
                    "cmp_sink"        : self.endpoint.packetizer.cmp_sink,
                    "packetizer_out"  : self.endpoint.packetizer.source,
                    "mem_depacketizer_in" : self.memory.endpoint.depacketizer.sink,
                    "mem_req_source"      : self.memory.endpoint.depacketizer.req_source,
                    "mem_cmp_source"      : self.memory.endpoint.depacketizer.cmp_source,
                    "mem_req_sink"        : self.memory.endpoint.packetizer.req_sink,
                    "mem_cmp_sink"        : self.memory.endpoint.packetizer.cmp_sink,
                    "mem_packetizer_out"  : self.memory.endpoint.packetizer.source,
                    "dmaram_sink"         : self.memory.dmaram.sink,
                    "dmaram_source"       : self.memory.dmaram.source,
                }
                
        generate_dut = lambda: DUT(data_width)

        # Generate gtkwave save file
        dut = generate_dut()
        from migen.fhdl import verilog
        from litex.build.sim import gtkwave as gtkw
        import os.path
        
        vns = verilog.convert(dut).ns
        with gtkw.GTKWSave(vns, os.path.splitext(vcd_name)[0] + ".gtkw", vcd_name, prefix="DUT.") as s:
            s.clocks()            
            for key, ep in dut.monitor_eps.items():
                s.add(ep, group_name=key)
        
        # Simulation
        dut = generate_dut()        
        generators = {
            "sys" : [
                main_generator(dut),
                dut.msi_handler.generator(dut),
            ]
        }
        clocks = {"sys": 10}
        run_simulation(dut, generators, clocks, vcd_name=vcd_name)
           
    #def test_dma_64b(self):
    #    self.dma_test(64, vcd_name="dma_ram_test_64b.vcd")
    
    def test_dma_256b(self):
        self.dma_test(256, vcd_name="dma_ram_test_256b.vcd")